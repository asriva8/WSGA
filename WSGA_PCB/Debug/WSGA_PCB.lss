
WSGA_PCB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000484  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00802000  00000484  000004f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000500  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000530  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000110  00000000  00000000  00000570  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004661  00000000  00000000  00000680  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00003712  00000000  00000000  00004ce1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000e2b  00000000  00000000  000083f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001dc  00000000  00000000  00009220  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000029a4  00000000  00000000  000093fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000008a5  00000000  00000000  0000bda0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  0000c645  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
   8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
   c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  10:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  14:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  18:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  1c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  20:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  24:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  28:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  2c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  30:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  34:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  38:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  3c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  40:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  44:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  48:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  4c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  50:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  54:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  58:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  5c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  60:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  64:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  68:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  6c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  70:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  74:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  78:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  7c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  80:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  84:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  88:	0c 94 af 01 	jmp	0x35e	; 0x35e <__vector_34>
  8c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  90:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  94:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  98:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  9c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  a0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  a4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  a8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  ac:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  b0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  b4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  b8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  bc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  c0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  c4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  c8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  cc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  d0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  d4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  d8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  dc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  e0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  e4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  e8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  ec:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  f0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  f4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  f8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
  fc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 100:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 104:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 108:	0c 94 19 01 	jmp	0x232	; 0x232 <__vector_66>
 10c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 110:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 114:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 118:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 11c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 120:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 124:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 128:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 12c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 130:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 134:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 138:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 13c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 140:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 144:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 148:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 14c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 150:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 154:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 158:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 15c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 160:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 164:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 168:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 16c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 170:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 174:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 178:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 17c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 180:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 184:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 188:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 18c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 190:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 194:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 198:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 19c:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1a0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1a4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1a8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1ac:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1b0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1b4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1b8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1bc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1c0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1c4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1c8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1cc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1d0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1d4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1d8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1dc:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1e0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1e4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1e8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1ec:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1f0:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1f4:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>
 1f8:	0c 94 17 01 	jmp	0x22e	; 0x22e <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e3       	ldi	r29, 0x3F	; 63
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	10 e2       	ldi	r17, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	e4 e8       	ldi	r30, 0x84	; 132
 214:	f4 e0       	ldi	r31, 0x04	; 4
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
 21e:	0d 92       	st	X+, r0
 220:	a8 30       	cpi	r26, 0x08	; 8
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>
 226:	0e 94 c0 01 	call	0x380	; 0x380 <main>
 22a:	0c 94 40 02 	jmp	0x480	; 0x480 <_exit>

0000022e <__bad_interrupt>:
 22e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000232 <__vector_66>:
 /*******************************************************************************************
 ISR(PORTA_INT0_vect): This function sends one byte COMMAND to ADC_C2
 *******************************************************************************************/

 ISR(PORTA_INT0_vect)
 {
 232:	1f 92       	push	r1
 234:	0f 92       	push	r0
 236:	0f b6       	in	r0, 0x3f	; 63
 238:	0f 92       	push	r0
 23a:	11 24       	eor	r1, r1
 23c:	8f 93       	push	r24
	 PORTR_DIRSET = 0x01;
 23e:	81 e0       	ldi	r24, 0x01	; 1
 240:	80 93 e1 07 	sts	0x07E1, r24	; 0x8007e1 <__TEXT_REGION_LENGTH__+0x7007e1>
	 PORTR_OUTTGL=0x01;
 244:	80 93 e7 07 	sts	0x07E7, r24	; 0x8007e7 <__TEXT_REGION_LENGTH__+0x7007e7>
 }
 248:	8f 91       	pop	r24
 24a:	0f 90       	pop	r0
 24c:	0f be       	out	0x3f, r0	; 63
 24e:	0f 90       	pop	r0
 250:	1f 90       	pop	r1
 252:	18 95       	reti

00000254 <setUp_ADC_D2>:
setUp_ADC_D2():	Sets up the SPI port for ADC_D2
*************************************************/

void setUp_ADC_D2()
{
	ADC_D2_CS_DIR_OUTPUT;
 254:	e1 e6       	ldi	r30, 0x61	; 97
 256:	f6 e0       	ldi	r31, 0x06	; 6
 258:	80 e1       	ldi	r24, 0x10	; 16
 25a:	80 83       	st	Z, r24
	ADC_D2_SCK_DIR_OUTPUT;
 25c:	80 e8       	ldi	r24, 0x80	; 128
 25e:	80 83       	st	Z, r24
	ADC_D2_MISO_DIR_INPUT;
 260:	80 e4       	ldi	r24, 0x40	; 64
 262:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <__TEXT_REGION_LENGTH__+0x700662>
	ADC_D2_MOSI_DIR_OUTPUT;
 266:	80 e2       	ldi	r24, 0x20	; 32
 268:	80 83       	st	Z, r24
	ADC_D2_START_DIR_OUTPUT;
 26a:	e1 e2       	ldi	r30, 0x21	; 33
 26c:	f6 e0       	ldi	r31, 0x06	; 6
 26e:	84 e0       	ldi	r24, 0x04	; 4
 270:	80 83       	st	Z, r24
	ADC_D2_RESET_DIR_OUTPUT;
 272:	88 e0       	ldi	r24, 0x08	; 8
 274:	80 83       	st	Z, r24
	ADC_D2_DRDY_DIR_INPUT;
 276:	82 e0       	ldi	r24, 0x02	; 2
 278:	80 93 22 06 	sts	0x0622, r24	; 0x800622 <__TEXT_REGION_LENGTH__+0x700622>

	/* Double clock=0, SPI enable = 1, DORD = 0(mSB first), MASTER = 1 (MASTER MODE), Transfer mode = 01 (mode 1), SCK frequency = 01 (CLK_PER/16 (bcoz Maximum = f_clk_ADS1259/1.8))  */
	ADC_D2_SPI_CTRL = 0b01010101;
 27c:	85 e5       	ldi	r24, 0x55	; 85
 27e:	80 93 c0 09 	sts	0x09C0, r24	; 0x8009c0 <__TEXT_REGION_LENGTH__+0x7009c0>
	ADC_D2_SPI_INTCTRL = 0x00; // Interrupts are disabled.
 282:	10 92 c1 09 	sts	0x09C1, r1	; 0x8009c1 <__TEXT_REGION_LENGTH__+0x7009c1>
 286:	08 95       	ret

00000288 <config_ADC_D2_registers>:

/*************************************************************
void config_ADC_D2_registers():	Configures ADC_D2 registers
**************************************************************/
void config_ADC_D2_registers()
{
 288:	cf 93       	push	r28
 28a:	df 93       	push	r29
	ADC_D2_RESET_PIN_HIGH;   //!RESET pin High.
 28c:	a5 e2       	ldi	r26, 0x25	; 37
 28e:	b6 e0       	ldi	r27, 0x06	; 6
 290:	88 e0       	ldi	r24, 0x08	; 8
 292:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 294:	8f e1       	ldi	r24, 0x1F	; 31
 296:	93 e0       	ldi	r25, 0x03	; 3
 298:	01 97       	sbiw	r24, 0x01	; 1
 29a:	f1 f7       	brne	.-4      	; 0x298 <config_ADC_D2_registers+0x10>
 29c:	00 c0       	rjmp	.+0      	; 0x29e <config_ADC_D2_registers+0x16>
 29e:	00 00       	nop
	_delay_us(100);
	ADC_D2_START_PIN_LOW;	// START pin Low.
 2a0:	84 e0       	ldi	r24, 0x04	; 4
 2a2:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <__TEXT_REGION_LENGTH__+0x700626>
 2a6:	cf e1       	ldi	r28, 0x1F	; 31
 2a8:	d3 e0       	ldi	r29, 0x03	; 3
 2aa:	21 97       	sbiw	r28, 0x01	; 1
 2ac:	f1 f7       	brne	.-4      	; 0x2aa <config_ADC_D2_registers+0x22>
 2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <config_ADC_D2_registers+0x28>
 2b0:	00 00       	nop
 2b2:	ef e1       	ldi	r30, 0x1F	; 31
 2b4:	f3 e0       	ldi	r31, 0x03	; 3
 2b6:	31 97       	sbiw	r30, 0x01	; 1
 2b8:	f1 f7       	brne	.-4      	; 0x2b6 <config_ADC_D2_registers+0x2e>
 2ba:	00 c0       	rjmp	.+0      	; 0x2bc <config_ADC_D2_registers+0x34>
 2bc:	00 00       	nop
	_delay_us(100);
	_delay_us(100);
	ADC_D2_CS_PIN_HIGH;		// !CS pin high
 2be:	8c 93       	st	X, r24
 2c0:	cf e3       	ldi	r28, 0x3F	; 63
 2c2:	df e1       	ldi	r29, 0x1F	; 31
 2c4:	21 97       	sbiw	r28, 0x01	; 1
 2c6:	f1 f7       	brne	.-4      	; 0x2c4 <config_ADC_D2_registers+0x3c>
 2c8:	00 c0       	rjmp	.+0      	; 0x2ca <config_ADC_D2_registers+0x42>
 2ca:	00 00       	nop
	_delay_us(1000);
	ADC_D2_CS_PIN_LOW;		// !CS pin LOW
 2cc:	8c 93       	st	X, r24
 2ce:	ef e3       	ldi	r30, 0x3F	; 63
 2d0:	ff e1       	ldi	r31, 0x1F	; 31
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <config_ADC_D2_registers+0x4a>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <config_ADC_D2_registers+0x50>
 2d8:	00 00       	nop
/*******************************************************************************************
void Send_Command_to_ADC_D2(uint8_t byte): This function sends one byte COMMAND to ADC_D2
*******************************************************************************************/
void Send_Command_to_ADC_D2(uint8_t byte)
{
	SPID_DATA = byte;
 2da:	e3 ec       	ldi	r30, 0xC3	; 195
 2dc:	f9 e0       	ldi	r31, 0x09	; 9
 2de:	91 e1       	ldi	r25, 0x11	; 17
 2e0:	90 83       	st	Z, r25
 2e2:	cf e1       	ldi	r28, 0x1F	; 31
 2e4:	d3 e0       	ldi	r29, 0x03	; 3
 2e6:	21 97       	sbiw	r28, 0x01	; 1
 2e8:	f1 f7       	brne	.-4      	; 0x2e6 <config_ADC_D2_registers+0x5e>
 2ea:	00 c0       	rjmp	.+0      	; 0x2ec <config_ADC_D2_registers+0x64>
 2ec:	00 00       	nop
 2ee:	90 83       	st	Z, r25
 2f0:	cf e1       	ldi	r28, 0x1F	; 31
 2f2:	d3 e0       	ldi	r29, 0x03	; 3
 2f4:	21 97       	sbiw	r28, 0x01	; 1
 2f6:	f1 f7       	brne	.-4      	; 0x2f4 <config_ADC_D2_registers+0x6c>
 2f8:	00 c0       	rjmp	.+0      	; 0x2fa <config_ADC_D2_registers+0x72>
 2fa:	00 00       	nop
 2fc:	92 e4       	ldi	r25, 0x42	; 66
 2fe:	90 83       	st	Z, r25
 300:	cf e1       	ldi	r28, 0x1F	; 31
 302:	d3 e0       	ldi	r29, 0x03	; 3
 304:	21 97       	sbiw	r28, 0x01	; 1
 306:	f1 f7       	brne	.-4      	; 0x304 <config_ADC_D2_registers+0x7c>
 308:	00 c0       	rjmp	.+0      	; 0x30a <config_ADC_D2_registers+0x82>
 30a:	00 00       	nop
 30c:	10 82       	st	Z, r1
 30e:	cf e1       	ldi	r28, 0x1F	; 31
 310:	d3 e0       	ldi	r29, 0x03	; 3
 312:	21 97       	sbiw	r28, 0x01	; 1
 314:	f1 f7       	brne	.-4      	; 0x312 <config_ADC_D2_registers+0x8a>
 316:	00 c0       	rjmp	.+0      	; 0x318 <config_ADC_D2_registers+0x90>
 318:	00 00       	nop
 31a:	96 e0       	ldi	r25, 0x06	; 6
 31c:	90 83       	st	Z, r25
 31e:	cf e1       	ldi	r28, 0x1F	; 31
 320:	d3 e0       	ldi	r29, 0x03	; 3
 322:	21 97       	sbiw	r28, 0x01	; 1
 324:	f1 f7       	brne	.-4      	; 0x322 <config_ADC_D2_registers+0x9a>
 326:	00 c0       	rjmp	.+0      	; 0x328 <config_ADC_D2_registers+0xa0>
 328:	00 00       	nop
 32a:	90 e1       	ldi	r25, 0x10	; 16
 32c:	90 83       	st	Z, r25
	_delay_us(100);

	//send the RDATAC (Read data continuous) command
	Send_Command_to_ADC_D2(0x10);

	ADC_D2_START_PIN_HIGH;  // START pin HIGH.
 32e:	8c 93       	st	X, r24
 330:	ef e1       	ldi	r30, 0x1F	; 31
 332:	f3 e0       	ldi	r31, 0x03	; 3
 334:	31 97       	sbiw	r30, 0x01	; 1
 336:	f1 f7       	brne	.-4      	; 0x334 <config_ADC_D2_registers+0xac>
 338:	00 c0       	rjmp	.+0      	; 0x33a <config_ADC_D2_registers+0xb2>
 33a:	00 00       	nop
	_delay_us(100);
}
 33c:	df 91       	pop	r29
 33e:	cf 91       	pop	r28
 340:	08 95       	ret

00000342 <setUp_ADC_D2_Interrupt>:
void setUp_ADC_D2(): This function sets up the interrupt for DRDY pin of ADC_D2
**************************************************************************/

void setUp_ADC_D2_Interrupt()
{
	ADC_D2_DRDYPINCTRL = PORT_OPC_PULLDOWN_gc | PORT_ISC_FALLING_gc;
 342:	82 e1       	ldi	r24, 0x12	; 18
 344:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <__TEXT_REGION_LENGTH__+0x700631>
	ADC_D2_SET_INTMASK;
 348:	82 e0       	ldi	r24, 0x02	; 2
 34a:	80 93 2a 06 	sts	0x062A, r24	; 0x80062a <__TEXT_REGION_LENGTH__+0x70062a>
	ADC_D2_ENABLE_INTERRUPT;
 34e:	80 93 29 06 	sts	0x0629, r24	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>
	// Enable low level interrupts
	PMIC.CTRL |= PMIC_MEDLVLEN_bm;
 352:	e0 ea       	ldi	r30, 0xA0	; 160
 354:	f0 e0       	ldi	r31, 0x00	; 0
 356:	82 81       	ldd	r24, Z+2	; 0x02
 358:	82 60       	ori	r24, 0x02	; 2
 35a:	82 83       	std	Z+2, r24	; 0x02
 35c:	08 95       	ret

0000035e <__vector_34>:
/*******************************************************************************************
ISR(PORTB_INT0_vect): This function sends one byte COMMAND to ADC_D2
*******************************************************************************************/

ISR(PORTB_INT0_vect)
{
 35e:	1f 92       	push	r1
 360:	0f 92       	push	r0
 362:	0f b6       	in	r0, 0x3f	; 63
 364:	0f 92       	push	r0
 366:	11 24       	eor	r1, r1
 368:	8f 93       	push	r24
	PORTR_DIRSET = 0x01;
 36a:	81 e0       	ldi	r24, 0x01	; 1
 36c:	80 93 e1 07 	sts	0x07E1, r24	; 0x8007e1 <__TEXT_REGION_LENGTH__+0x7007e1>
	PORTR_OUTTGL=0x01;
 370:	80 93 e7 07 	sts	0x07E7, r24	; 0x8007e7 <__TEXT_REGION_LENGTH__+0x7007e7>
}
 374:	8f 91       	pop	r24
 376:	0f 90       	pop	r0
 378:	0f be       	out	0x3f, r0	; 63
 37a:	0f 90       	pop	r0
 37c:	1f 90       	pop	r1
 37e:	18 95       	reti

00000380 <main>:
#include "XBee.h"
#include "ADC_D2.h"


int main(void)
{
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	cd b7       	in	r28, 0x3d	; 61
 386:	de b7       	in	r29, 0x3e	; 62
 388:	28 97       	sbiw	r28, 0x08	; 8
 38a:	cd bf       	out	0x3d, r28	; 61
 38c:	de bf       	out	0x3e, r29	; 62
	setUp32MhzInternalOsc();
 38e:	0e 94 fd 01 	call	0x3fa	; 0x3fa <setUp32MhzInternalOsc>
	setUp_XBEE();
 392:	0e 94 17 02 	call	0x42e	; 0x42e <setUp_XBEE>
	setUp_ADC_D2();
 396:	0e 94 2a 01 	call	0x254	; 0x254 <setUp_ADC_D2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 39a:	2f ef       	ldi	r18, 0xFF	; 255
 39c:	83 ec       	ldi	r24, 0xC3	; 195
 39e:	99 e0       	ldi	r25, 0x09	; 9
 3a0:	21 50       	subi	r18, 0x01	; 1
 3a2:	80 40       	sbci	r24, 0x00	; 0
 3a4:	90 40       	sbci	r25, 0x00	; 0
 3a6:	e1 f7       	brne	.-8      	; 0x3a0 <main+0x20>
 3a8:	00 c0       	rjmp	.+0      	; 0x3aa <main+0x2a>
 3aa:	00 00       	nop
	_delay_ms(100);
	config_ADC_D2_registers();
 3ac:	0e 94 44 01 	call	0x288	; 0x288 <config_ADC_D2_registers>
	setUp_ADC_D2_Interrupt();
 3b0:	0e 94 a1 01 	call	0x342	; 0x342 <setUp_ADC_D2_Interrupt>
	//Initialize_ADC_D2();
	uint8_t data;
	sei();
 3b4:	78 94       	sei
	uint8_t byte[8] = {0x00, 0x65, 0x62, 0x69, 0x60, 0x61, 0x63, 0xff};
 3b6:	88 e0       	ldi	r24, 0x08	; 8
 3b8:	e0 e0       	ldi	r30, 0x00	; 0
 3ba:	f0 e2       	ldi	r31, 0x20	; 32
 3bc:	de 01       	movw	r26, r28
 3be:	11 96       	adiw	r26, 0x01	; 1
 3c0:	01 90       	ld	r0, Z+
 3c2:	0d 92       	st	X+, r0
 3c4:	8a 95       	dec	r24
 3c6:	e1 f7       	brne	.-8      	; 0x3c0 <main+0x40>
 3c8:	7e 01       	movw	r14, r28
 3ca:	e9 e0       	ldi	r30, 0x09	; 9
 3cc:	ee 0e       	add	r14, r30
 3ce:	f1 1c       	adc	r15, r1
 3d0:	8e 01       	movw	r16, r28
 3d2:	0f 5f       	subi	r16, 0xFF	; 255
 3d4:	1f 4f       	sbci	r17, 0xFF	; 255
	while (1)
	{
		for (uint8_t i =0; i<8; ++i)
		{
			send_Byte_To_XBEE(byte[i]);
 3d6:	f8 01       	movw	r30, r16
 3d8:	81 91       	ld	r24, Z+
 3da:	8f 01       	movw	r16, r30
 3dc:	0e 94 38 02 	call	0x470	; 0x470 <send_Byte_To_XBEE>
	uint8_t data;
	sei();
	uint8_t byte[8] = {0x00, 0x65, 0x62, 0x69, 0x60, 0x61, 0x63, 0xff};
	while (1)
	{
		for (uint8_t i =0; i<8; ++i)
 3e0:	0e 15       	cp	r16, r14
 3e2:	1f 05       	cpc	r17, r15
 3e4:	c1 f7       	brne	.-16     	; 0x3d6 <main+0x56>
 3e6:	ff ef       	ldi	r31, 0xFF	; 255
 3e8:	21 ee       	ldi	r18, 0xE1	; 225
 3ea:	84 e0       	ldi	r24, 0x04	; 4
 3ec:	f1 50       	subi	r31, 0x01	; 1
 3ee:	20 40       	sbci	r18, 0x00	; 0
 3f0:	80 40       	sbci	r24, 0x00	; 0
 3f2:	e1 f7       	brne	.-8      	; 0x3ec <main+0x6c>
 3f4:	00 c0       	rjmp	.+0      	; 0x3f6 <main+0x76>
 3f6:	00 00       	nop
 3f8:	eb cf       	rjmp	.-42     	; 0x3d0 <main+0x50>

000003fa <setUp32MhzInternalOsc>:
#include "uc_clock.h"


void setUp32MhzInternalOsc()
{
	OSC.CTRL |= OSC_RC32MEN_bm | OSC_RC32KEN_bm;  /* Enable the internal 32MHz & 32KHz oscillators */
 3fa:	e0 e5       	ldi	r30, 0x50	; 80
 3fc:	f0 e0       	ldi	r31, 0x00	; 0
 3fe:	80 81       	ld	r24, Z
 400:	86 60       	ori	r24, 0x06	; 6
 402:	80 83       	st	Z, r24
	while(!(OSC.STATUS & OSC_RC32KRDY_bm));       /* Wait for 32Khz oscillator to stabilize */
 404:	81 81       	ldd	r24, Z+1	; 0x01
 406:	82 ff       	sbrs	r24, 2
 408:	fd cf       	rjmp	.-6      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
	while(!(OSC.STATUS & OSC_RC32MRDY_bm));       /* Wait for 32MHz oscillator to stabilize */
 40a:	e0 e5       	ldi	r30, 0x50	; 80
 40c:	f0 e0       	ldi	r31, 0x00	; 0
 40e:	81 81       	ldd	r24, Z+1	; 0x01
 410:	81 ff       	sbrs	r24, 1
 412:	fd cf       	rjmp	.-6      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
	DFLLRC32M.CTRL = DFLL_ENABLE_bm ;             /* Enable DFLL - defaults to calibrate against internal 32Khz clock */
 414:	81 e0       	ldi	r24, 0x01	; 1
 416:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	CCP = CCP_IOREG_gc;                           /* Disable register security for clock update */
 41a:	98 ed       	ldi	r25, 0xD8	; 216
 41c:	94 bf       	out	0x34, r25	; 52
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc;              /* Switch to 32MHz clock */
 41e:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	OSC.CTRL &= ~OSC_RC2MEN_bm;                   /* Disable 2Mhz oscillator */
 422:	e0 e5       	ldi	r30, 0x50	; 80
 424:	f0 e0       	ldi	r31, 0x00	; 0
 426:	80 81       	ld	r24, Z
 428:	8e 7f       	andi	r24, 0xFE	; 254
 42a:	80 83       	st	Z, r24
 42c:	08 95       	ret

0000042e <setUp_XBEE>:
to communicate with the XBEE
************************************************************************************/
void setUp_XBEE()
{
	// Setting the direction of the pins on the port for XBEE pins.
	TO_XBEE_DIR_OUTPUT;
 42e:	e1 ea       	ldi	r30, 0xA1	; 161
 430:	f6 e0       	ldi	r31, 0x06	; 6
 432:	88 e0       	ldi	r24, 0x08	; 8
 434:	80 83       	st	Z, r24
	RESET_XBEE_DIR_OUTPUT;
 436:	80 e1       	ldi	r24, 0x10	; 16
 438:	80 83       	st	Z, r24
	DTR_XBEE_DIR_OUTPUT;
 43a:	90 e2       	ldi	r25, 0x20	; 32
 43c:	90 83       	st	Z, r25
	FROM_XBEE_DIR_INPUT;
 43e:	e2 ea       	ldi	r30, 0xA2	; 162
 440:	f6 e0       	ldi	r31, 0x06	; 6
 442:	94 e0       	ldi	r25, 0x04	; 4
 444:	90 83       	st	Z, r25
	CTS_XBEE_DIR_INPUT;
 446:	90 e4       	ldi	r25, 0x40	; 64
 448:	90 83       	st	Z, r25
	RTS_XBEE_DIR_INPUT;
 44a:	90 e8       	ldi	r25, 0x80	; 128
 44c:	90 83       	st	Z, r25

	// Setting RESET_XBEE pin HIGH. (RESET is ACTIVE_LOW on XBEE)
	RESET_XBEE_PIN_HIGH;
 44e:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>

	// for 32MHZ f_per and 115,200 baud rate.
	// BSEL = 131
	//BSCALE = -3 .........  This is set by upper four bits of BAUDCTRLB register in 2's complement form.
	XBEE_USART_BAUDCTRLB = 0b11010000; //Upper four bits -3 in two's complement form
 452:	80 ed       	ldi	r24, 0xD0	; 208
 454:	80 93 a7 0b 	sts	0x0BA7, r24	; 0x800ba7 <__TEXT_REGION_LENGTH__+0x700ba7>
	XBEE_USART_BAUDCTRLA = 0x83; // 131
 458:	83 e8       	ldi	r24, 0x83	; 131
 45a:	80 93 a6 0b 	sts	0x0BA6, r24	; 0x800ba6 <__TEXT_REGION_LENGTH__+0x700ba6>
	//Disable interrupts, just for safety
	XBEE_USART_CTRLA = 0;
 45e:	10 92 a3 0b 	sts	0x0BA3, r1	; 0x800ba3 <__TEXT_REGION_LENGTH__+0x700ba3>
	//8 data bits, no parity and 1 stop bit
	XBEE_USART_CTRLC = USART_CHSIZE_8BIT_gc;
 462:	83 e0       	ldi	r24, 0x03	; 3
 464:	80 93 a5 0b 	sts	0x0BA5, r24	; 0x800ba5 <__TEXT_REGION_LENGTH__+0x700ba5>
	//Enable receive and transmit
	XBEE_USART_CTRLB = USART_TXEN_bm | USART_RXEN_bm; // And enable high speed mode
 468:	88 e1       	ldi	r24, 0x18	; 24
 46a:	80 93 a4 0b 	sts	0x0BA4, r24	; 0x800ba4 <__TEXT_REGION_LENGTH__+0x700ba4>
 46e:	08 95       	ret

00000470 <send_Byte_To_XBEE>:
void send_Byte_To_XBEE(uint8_t byte) : This function sends a byte to the TO_XBEE pin.
************************************************************************************/

void send_Byte_To_XBEE(uint8_t byte)
{
	while( !(USARTF0_STATUS & USART_DREIF_bm) ); //Wait until DATA buffer is empty
 470:	e1 ea       	ldi	r30, 0xA1	; 161
 472:	fb e0       	ldi	r31, 0x0B	; 11
 474:	90 81       	ld	r25, Z
 476:	95 ff       	sbrs	r25, 5
 478:	fd cf       	rjmp	.-6      	; 0x474 <send_Byte_To_XBEE+0x4>
	USARTF0_DATA = byte;
 47a:	80 93 a0 0b 	sts	0x0BA0, r24	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
 47e:	08 95       	ret

00000480 <_exit>:
 480:	f8 94       	cli

00000482 <__stop_program>:
 482:	ff cf       	rjmp	.-2      	; 0x482 <__stop_program>
